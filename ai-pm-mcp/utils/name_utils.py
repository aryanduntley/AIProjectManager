"""
Name Normalization and Validation Utilities
General-purpose utilities for cleaning and validating names (branch names, identifiers, etc.)
Extracted from the original instance management system for reuse with Git branches
"""

import re
from typing import Dict, Any, List


class NameUtils:
    """General-purpose name normalization and validation utilities."""
    
    # Common reserved names to avoid across different contexts
    RESERVED_NAMES = [
        "main", "master", "develop", "dev", "test", "testing", 
        "staging", "stage", "prod", "production", "release",
        "hotfix", "feature", "bugfix", "temp", "tmp"
    ]
    
    @staticmethod
    def normalize_name(name: str, suffix: str = "") -> str:
        """
        Clean and normalize a name for use as identifier.
        
        Args:
            name: Raw name to normalize
            suffix: Optional suffix to append (like username)
            
        Returns:
            Normalized name safe for use as identifier
        """
        if not name:
            return ""
        
        # Clean and normalize the name
        clean_name = re.sub(r'[^\w\-]', '-', name.lower())
        clean_name = re.sub(r'-+', '-', clean_name).strip('-')
        
        # Add suffix if provided and not already in name
        if suffix and suffix != "ai" and suffix not in clean_name:
            return f"{clean_name}-{suffix.lower()}"
        
        return clean_name
    
    @staticmethod
    def normalize_branch_name(name: str) -> str:
        """
        Normalize a name for use as Git branch name.
        
        Args:
            name: Base name for the branch
            
        Returns:
            Normalized Git branch name following ai-pm-org-branch-{XXX} pattern
        """
        normalized_name = NameUtils.normalize_name(name)
        
        if not normalized_name:
            normalized_name = "work"
        
        # Build branch name - for sequential numbering, this is just validation
        # Actual branch names are generated by the branch manager with sequential numbers
        return f"ai-pm-org-branch-{normalized_name}"
    
    @staticmethod
    def validate_identifier(identifier: str, min_length: int = 3, max_length: int = 50,
                          allow_reserved: bool = False, 
                          custom_reserved: List[str] = None) -> Dict[str, Any]:
        """
        Validate an identifier follows naming conventions.
        
        Args:
            identifier: Identifier to validate
            min_length: Minimum length requirement
            max_length: Maximum length requirement
            allow_reserved: Whether to allow reserved names
            custom_reserved: Additional reserved names to check
            
        Returns:
            Dictionary with 'valid' boolean and 'message' string
        """
        # Check basic format requirements
        if not identifier:
            return {
                "valid": False,
                "message": "Identifier cannot be empty"
            }
        
        if len(identifier) < min_length:
            return {
                "valid": False,
                "message": f"Identifier must be at least {min_length} characters long"
            }
        
        if len(identifier) > max_length:
            return {
                "valid": False,
                "message": f"Identifier must be {max_length} characters or less"
            }
        
        # Check character restrictions - allow alphanumeric, hyphens, underscores
        if not re.match(r'^[a-zA-Z0-9\-_]+$', identifier):
            return {
                "valid": False,
                "message": "Identifier can only contain letters, numbers, hyphens, and underscores"
            }
        
        # Check for reserved names if not allowed
        if not allow_reserved:
            reserved_names = set(NameUtils.RESERVED_NAMES)
            if custom_reserved:
                reserved_names.update(custom_reserved)
            
            if identifier.lower() in reserved_names:
                return {
                    "valid": False,
                    "message": f"'{identifier}' is a reserved name"
                }
        
        return {
            "valid": True,
            "message": "Identifier is valid"
        }
    
    @staticmethod
    def validate_branch_name(branch_name: str) -> Dict[str, Any]:
        """
        Validate a Git branch name follows Git naming conventions.
        
        Args:
            branch_name: Branch name to validate
            
        Returns:
            Dictionary with 'valid' boolean and 'message' string
        """
        if not branch_name:
            return {
                "valid": False,
                "message": "Branch name cannot be empty"
            }
        
        # Git branch name restrictions
        # Cannot start or end with slash, cannot have double slash
        if branch_name.startswith('/') or branch_name.endswith('/'):
            return {
                "valid": False,
                "message": "Branch name cannot start or end with slash"
            }
        
        if '//' in branch_name:
            return {
                "valid": False,
                "message": "Branch name cannot contain double slash"
            }
        
        # Cannot contain certain characters
        invalid_chars = [' ', '~', '^', ':', '?', '*', '[', '\\', '\x7f']
        for char in invalid_chars:
            if char in branch_name:
                return {
                    "valid": False,
                    "message": f"Branch name cannot contain '{char}'"
                }
        
        # Cannot end with .lock
        if branch_name.endswith('.lock'):
            return {
                "valid": False,
                "message": "Branch name cannot end with '.lock'"
            }
        
        # Cannot be just dots
        if branch_name in ['.', '..']:
            return {
                "valid": False,
                "message": "Branch name cannot be '.' or '..'"
            }
        
        # Length check (reasonable limit)
        if len(branch_name) > 250:
            return {
                "valid": False,
                "message": "Branch name is too long (max 250 characters)"
            }
        
        return {
            "valid": True,
            "message": "Branch name is valid"
        }
    
    @staticmethod
    def suggest_alternatives(name: str, existing_names: List[str], max_suggestions: int = 3) -> List[str]:
        """
        Suggest alternative names when the desired name conflicts.
        
        Args:
            name: Desired name that conflicts
            existing_names: List of existing names to avoid
            max_suggestions: Maximum number of suggestions to return
            
        Returns:
            List of suggested alternative names
        """
        suggestions = []
        base_name = NameUtils.normalize_name(name)
        
        # Try with numbers
        for i in range(2, max_suggestions + 2):
            candidate = f"{base_name}-{i}"
            if candidate not in existing_names:
                suggestions.append(candidate)
                if len(suggestions) >= max_suggestions:
                    break
        
        # If still need more suggestions, try with descriptive suffixes
        if len(suggestions) < max_suggestions:
            suffixes = ["alt", "new", "updated", "v2", "revised"]
            for suffix in suffixes:
                candidate = f"{base_name}-{suffix}"
                if candidate not in existing_names and candidate not in suggestions:
                    suggestions.append(candidate)
                    if len(suggestions) >= max_suggestions:
                        break
        
        return suggestions
    
    @staticmethod
    def extract_name_components(full_name: str, separator: str = "-") -> Dict[str, str]:
        """
        Extract components from a structured name.
        
        Args:
            full_name: Full structured name to parse
            separator: Character used to separate components
            
        Returns:
            Dictionary with extracted components
        """
        if not full_name:
            return {}
        
        parts = full_name.split(separator)
        components = {}
        
        # For AI PM branch names like "ai-pm-org-branch-001"
        if len(parts) >= 4 and parts[0] == "ai" and parts[1] == "pm" and parts[2] == "org" and parts[3] == "branch":
            components["system"] = f"{parts[0]}-{parts[1]}-{parts[2]}-{parts[3]}"
            
            if len(parts) > 4:
                components["number"] = parts[4]
        else:
            # Generic parsing
            components["full"] = full_name
            if len(parts) > 1:
                components["base"] = parts[0]
                components["suffix"] = separator.join(parts[1:])
        
        return components